filter {

    # Save original message, clear out logstash-isms
    ruby {
      code => '
        event.set("[event][original]", event.to_hash)
        event.remove("[event][original][@metadata]")
        event.remove("[event][original][@timestamp]")
      '
      tag_on_exception => "_rubyexception-suricata-event-original"

    }

    # Populate event.created and parse event @timestamp
    mutate {
      rename => {"[@timestamp]" => "[event][created]"}
    }

    date {
      match => ["timestamp", "ISO8601"]
      remove_field => ["timestamp"]
      tag_on_failure => [ "_dateparsefailure", "_parsefailure", "_suricata_dateparsefailure" ]
    }

    mutate {
      add_field => {
        "[related][domain]" => []
        "[related][ip]" => []
        "[related][id]" => []
        "[related][vlan]" => []
        "[event][module]" => "suricata"
        "[event][created]" => "%{[@timestamp]}"
        "[event][type]" => "info"
        "[event][dataset]" => "suricata.%{event_type}"
        "[event][category]" => "intrusion_detection"
        "[ecs][version]" => "1.4"
      }
      remove_field => ["event_type"]
    }

    # If this is a network related event (i.e. not stats), it will have a flow id
    if [flow_id] {
        mutate {
          # Make this compatible with event.id as a string
          convert => { "[flow_id]" => "string" }
          rename => {
            "proto" => "[network][transport]"
            "flow_id" => "[event][id]"
            "community_id" => "[network][community_id]"
          }
          lowercase => [ "[network][transport]" ]
          merge => {"[event][id]" => "[related][id]" }
          replace => {"[event][category]" => "network_traffic"}
        }

      mutate {
	      copy => {"[src_ip]" => "[source][address]"}
        rename => {
          "[src_ip]" => "[source][ip]"
          "[src_port]" => "[source][port]"
        }
        merge => { "[related][ip]" => "[source][ip]" }

        copy => {"[dest_ip]" => "[destination][address]"}
        rename => {
          "[dest_ip]" => "[destination][ip]"
          "[dest_port]" => "[destination][port]"
        }
        merge => { "[related][ip]" => "[destination][ip]" }
      }

      if [vlan] {
        mutate {
          rename => { "[vlan]" => "[vlan][id]" }
          merge => {"[related][id]" => "[vlan][id]"}
        }
      }

    if [app_proto] {
      if [app_proto] == "failed" {
        # delete failed detections to be consistent with zeek
        mutate { rename => { "app_proto" => "[error][message]" } }
      }
      else {
        mutate { rename => {"app_proto" => "[network][protocol]"}}
      }
    }
  }
}
