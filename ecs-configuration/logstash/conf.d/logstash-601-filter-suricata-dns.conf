filter {
  if [@metadata][stage] == 'suricata_json' {
    if [dns] {

      #json {
      #    source => "[dns][answers]"
      #    target => "temp_answers"
      #    remove_field => "answers"
      #  #rename => {
      #  #  "[dns][answers][rrname]" => "[dns][question][name]"
      #  #  "[dns][answers][rrtype]" => "[dns][question][type]"
      #  #  "[dns][answers][rdata]" => "[dns][answers][name]"
      #  #}
      #}
      #ruby {
      #  code => "event.get('temp_answers').each { |kv| event.set(kv['rrname'], kv['rrtype'], kv['rdata']) }"
      #}
      mutate { rename => { "[dns][answers]" => "[suricata][dns][answers]" } }
      mutate { rename => { "[dns][authorities]" => "[suricata][dns][authorities]" } }

      mutate {
        rename => {
          "[dns][rcode]" => "[dns][response_code]"
          "[dns][rrname]" => "[dns][question][name]"
          "[dns][rrtype]" => "[dns][question][type]"
          "[dns][rdata]" => "[dns][answers][name]"
        }
      }

      # We can only do this analysis when there's a DNS response
      if [dns][type] == 'answer' {
        ruby {
          path => "/etc/logstash/conf.d/ruby/logstash-ruby-filter-dns-related.rb"
          script_params => {
            "query_field" => "[dns][question][name]"
            "query_type_field" => "[dns][question][type]"
            "answers_field" => "[dns][answers][name]"
          }
          tag_on_exception => "_rubyexception-suricata-dns_related_enrichment"
        }
      }

    }
  }
}
